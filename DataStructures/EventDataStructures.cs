// Advanced data structures for managing events including sorted dictionaries and search pattern tracking
using CivicLink.Models;

namespace CivicLink.DataStructures
{
    /* 
     * Summary: Contains specialized data structures for the events system.
     * Uses SortedDictionary for event storage, Queue for recommendations,
     * Stack for recently viewed, and HashSet for category management.
     */

    // Main storage for events using sorted dictionary sorted by date
    // Ive become quite familiar with SortedDictionary now so I decided to use it here
    public class EventSortedDictionary
    {
        // Events stored by ID in sorted order
        // being sorted by ID allows for quick lookups and ordered traversal
        private SortedDictionary<int, Event> events;

        public EventSortedDictionary()
        {
            events = new SortedDictionary<int, Event>();
        }

        // Add a new event to the dictionary
        // very simple add method
        public void Add(Event ev)
        {
            if (ev != null && !events.ContainsKey(ev.Id))
            {
                events.Add(ev.Id, ev);
            }
        }

        // Get a specific event by its ID
        // very simple
        public Event GetById(int id)
        {
            if (events.ContainsKey(id))
            {
                return events[id];
            }
            return null;
        }

        // Get all events as a list
        public List<Event> GetAll()
        {
            return events.Values.ToList();
        }

        // Get events sorted by date
        // Again, just another way of sorting events
        public List<Event> GetSortedByDate()
        {
            return events.Values.OrderBy(e => e.StartDate).ToList();
        }

        // Get events by specific category
        public List<Event> GetByCategory(EventCategory category)
        {
            return events.Values.Where(e => e.Category == category).ToList();
        }

    
        // Get events happening on a specific date
        public List<Event> GetByDate(DateTime date)
        {
            return events.Values
                .Where(e => e.StartDate.Date == date.Date ||
                           (e.EndDate.HasValue && e.EndDate.Value.Date == date.Date))
                .ToList();
        }

        // Remove an event from the dictionary
        // Simple remove method
        public bool Remove(int id)
        {
            return events.Remove(id);
        }

        // Check if an event exists
        public bool Contains(int id)
        {
            return events.ContainsKey(id);
        }

        // Get total count of events
        // Just a small UI thing
        public int Count => events.Count;
    }


    // Tracks user search patterns for recommendations
    // I originally tried my own method for searching however I kept hitting a runtime error so I asked claude to help fix it for me
    // This really took a while to get right but I think its a good implementation now, it was quite complex to me however some research helped:
    // Based on Microsoft Docs: Dictionary, Queue, List, and LINQ usage
    // https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2
    // https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1
    // https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1

    /* 
     * ============================================
     * Generated by Claude 2025-10-14
     * ============================================
     */
    public class SearchPatternTracker
    {
        // How many times each category has been searched
        private Dictionary<EventCategory, int> categorySearchCount;

        // Recently searched dates
        private Queue<DateTime> recentDateSearches;

        // Search terms used
        private List<string> searchTerms;

        public SearchPatternTracker()
        {
            categorySearchCount = new Dictionary<EventCategory, int>();
            recentDateSearches = new Queue<DateTime>();
            searchTerms = new List<string>();
        }

        // Record when user searches for a category
        public void RecordCategorySearch(EventCategory category)
        {
            if (categorySearchCount.ContainsKey(category))
            {
                categorySearchCount[category]++;
            }
            else
            {
                categorySearchCount.Add(category, 1);
            }
        }

        // Record when user searches for a date
        public void RecordDateSearch(DateTime date)
        {
            recentDateSearches.Enqueue(date);

            // Keep only last 10 date searches
            if (recentDateSearches.Count > 10)
            {
                recentDateSearches.Dequeue();
            }
        }

        // Record search term used
        public void RecordSearchTerm(string term)
        {
            if (!string.IsNullOrWhiteSpace(term))
            {
                searchTerms.Add(term.ToLower());
            }
        }

        // Get the most searched category
        public EventCategory? GetMostSearchedCategory()
        {
            if (categorySearchCount.Count == 0)
            {
                return null;
            }

            return categorySearchCount.OrderByDescending(x => x.Value).First().Key;
        }

        // Get top 3 most searched categories
        public List<EventCategory> GetTopCategories(int count = 3)
        {
            return categorySearchCount
                .OrderByDescending(x => x.Value)
                .Take(count)
                .Select(x => x.Key)
                .ToList();
        }

        // Get recent date searches
        public List<DateTime> GetRecentDateSearches()
        {
            return recentDateSearches.ToList();
        }

        // Check if user has searched for this term before
        public bool HasSearchedTerm(string term)
        {
            return searchTerms.Contains(term.ToLower());
        }
    }
    //============================================

    // Manages recently viewed events using a stack
    public class RecentlyViewedStack
    {
        // Stack to store recently viewed events
        private Stack<Event> viewedEvents;

        // Maximum number of events to remember
        private const int MaxSize = 10;

        public RecentlyViewedStack()
        {
            viewedEvents = new Stack<Event>();
        }

        // Add an event to recently viewed
        public void Push(Event ev)
        {
            // Remove if already exists to avoid duplicates
            var tempList = viewedEvents.ToList();
            tempList.RemoveAll(e => e.Id == ev.Id);

            viewedEvents = new Stack<Event>(tempList.Reverse<Event>());
            viewedEvents.Push(ev);

            // Keep only recent items
            while (viewedEvents.Count > MaxSize)
            {
                var items = viewedEvents.ToList();
                items.RemoveAt(items.Count - 1);
                viewedEvents = new Stack<Event>(items.Reverse<Event>());
            }
        }

        // Get recently viewed events
        public List<Event> GetRecent(int count = 5)
        {
            return viewedEvents.Take(count).ToList();
        }

        // Clear all viewed events
        public void Clear()
        {
            viewedEvents.Clear();
        }

        public int Count => viewedEvents.Count;
    }

    // Manages unique event categories using HashSet
    public class CategoryManager
    {
        // Set of all active categories
        private HashSet<EventCategory> activeCategories;

        public CategoryManager()
        {
            activeCategories = new HashSet<EventCategory>();
        }

        // Add a category to the active set
        public bool Add(EventCategory category)
        {
            return activeCategories.Add(category);
        }

        // Check if category is active
        public bool Contains(EventCategory category)
        {
            return activeCategories.Contains(category);
        }

        // Get all active categories
        public HashSet<EventCategory> GetAll()
        {
            return new HashSet<EventCategory>(activeCategories);
        }

        // Remove a category
        public bool Remove(EventCategory category)
        {
            return activeCategories.Remove(category);
        }

        public int Count => activeCategories.Count;
    }
}